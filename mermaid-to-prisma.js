#!/usr/bin/env node
/**
 * mermaid-to-prisma.js
 * Very lightweight converter from a *subset* of Mermaid ERD syntax to a Prisma schema.
 * Targeted to the ERD style used in the Video Quiz App docs.
 *
 * Usage:
 *   node mermaid-to-prisma.js path/to/erd.mmd > schema.prisma
 *
 * Limitations:
 * - Parses entity blocks and field lines inside them.
 * - Supports primitive types: string -> String, int -> Int, bool -> Boolean, datetime -> DateTime, json -> Json
 * - Supports arrays like string[] -> String[]
 * - Ignores relationship arrows (the ERD relationships) â€” add @relation manually after generation.
 * - Recognizes 'PK', 'FK', 'UNIQUE', 'index(...)' as hints; converts some to Prisma annotations.
 */

const fs = require('fs');

const inputPath = process.argv[2];
if (!inputPath) {
  console.error('Usage: node mermaid-to-prisma.js path/to/erd.mmd > schema.prisma');
  process.exit(1);
}

const src = fs.readFileSync(inputPath, 'utf8');

// Extract entity blocks: lines between 'NAME {' and '}'
const entityRegex = /([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*([^}]+)\}/gms;

function mapType(t) {
  const arr = /\[\]$/.test(t);
  const base = arr ? t.slice(0, -2) : t;
  let prisma = 'String';
  switch (base.toLowerCase()) {
    case 'string': prisma = 'String'; break;
    case 'int': prisma = 'Int'; break;
    case 'bool': prisma = 'Boolean'; break;
    case 'boolean': prisma = 'Boolean'; break;
    case 'datetime': prisma = 'DateTime'; break;
    case 'json': prisma = 'Json'; break;
    case 'enum': prisma = 'String'; break; // keep as string; define enums manually after
    default:
      prisma = 'String';
  }
  return arr ? `${prisma}[]` : prisma;
}

function parseFields(blockText) {
  const lines = blockText
    .split('\n')
    .map(l => l.trim())
    .filter(Boolean);

  const fields = [];
  const indices = [];

  for (const line of lines) {
    // Example field lines:
    // 'string id PK'
    // 'string moduleId FK UNIQUE'
    // 'int order UNIQUE'
    // 'string[] options'
    // 'index (userId, quizId)'
    if (/^index\s*\(/i.test(line)) {
      const cols = line.replace(/^index\s*\(|\)\s*$/gi, '').split(',').map(s => s.trim()).filter(Boolean);
      if (cols.length) indices.push(cols);
      continue;
    }

    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    const [typeRaw, name, ...flags] = parts;
    const prismaType = mapType(typeRaw);

    let attrs = '';
    if (flags.includes('PK')) attrs += ' @id';
    if (flags.some(f => f.toUpperCase() === 'UNIQUE')) attrs += ' @unique';

    // Basic FK hint: if field ends with 'Id' and has FK flag, leave a comment.
    const isFK = flags.includes('FK');
    const comment = isFK ? ' // FK' : '';

    fields.push(`  ${name} ${prismaType}${attrs}${comment}`);
  }

  return { fields, indices };
}

let schemaModels = [];
let schemaIndices = [];

let match;
while ((match = entityRegex.exec(src)) !== null) {
  const name = match[1];
  const body = match[2];
  const { fields, indices } = parseFields(body);
  const model = `model ${name} {\n${fields.join('\n')}\n}`;
  schemaModels.push(model);
  if (indices.length) {
    schemaIndices.push({ name, indices });
  }
}

let output = `// Generated by mermaid-to-prisma.js (subset support)\n` +
`// Review and add @relation annotations for FKs, adjust enums, and set defaults as needed.\n\n` +
`generator client {\n  provider = "prisma-client-js"\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\n` +
schemaModels.join('\n\n') + '\n\n';

// Append indices
for (const { name, indices } of schemaIndices) {
  output += `// Indexes for ${name}\n`;
  for (const cols of indices) {
    output += `// @@index([${cols.join(', ')}])\n`;
  }
  output += '\n';
}

process.stdout.write(output);
